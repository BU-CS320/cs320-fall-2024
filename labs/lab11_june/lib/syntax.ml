
open Format

type unary_op =
  | Neg
  | Not

type binary_op =
  (* integer *)
  | Add
  | Sub
  | Mul
  | Div
  (* boolean *)
  | And
  | Or
  (* compare *)
  | Lt
  | Gt
  | Lte
  | Gte
  | Eq
  | Neq

type ty =
  | TInt
  | TBool
  | TArrow of ty * ty

type expr =
  | Ann of expr * ty
  | EInt of int
  | EBool of bool
  | UnaryOp of unary_op * expr
  | BinaryOp of binary_op * expr * expr
  | Var of string
  | Fun of string * string * expr
  | App of expr * expr
  | Let of string * expr * expr
  | Ifte of expr * expr * expr

type env = (string * value) list
and value =
  | VInt of int
  | VBool of bool
  | VClo of (string * string * expr * env)


(* ******************************************** *)

(* \/ pretty printers generated by chatgpt \/ *)
(* note: I've found chatgpt is pretty good at making pretty printers *)
(* which is actually kinda something I'd recommend using it for *)

(* Pretty-printer for unary operators *)
let pp_unary_op fmt = function
  | Neg -> fprintf fmt "-"
  | Not -> fprintf fmt "not"

(* Pretty-printer for binary operators *)
let pp_binary_op fmt = function
  | Add -> fprintf fmt "+"
  | Sub -> fprintf fmt "-"
  | Mul -> fprintf fmt "*"
  | Div -> fprintf fmt "/"
  | And -> fprintf fmt "&&"
  | Or -> fprintf fmt "||"
  | Lt -> fprintf fmt "<"
  | Gt -> fprintf fmt ">"
  | Lte -> fprintf fmt "<="
  | Gte -> fprintf fmt ">="
  | Eq -> fprintf fmt "=="
  | Neq -> fprintf fmt "!="

(* Pretty-printer for types *)
let rec pp_ty fmt = function
  | TInt -> fprintf fmt "int"
  | TBool -> fprintf fmt "bool"
  | TArrow (t1, t2) -> fprintf fmt "(%a -> %a)" pp_ty t1 pp_ty t2

(* Pretty-printer for expressions *)
let rec pp_expr fmt = function
  | Ann (e, t) -> fprintf fmt "(%a : %a)" pp_expr e pp_ty t
  | EInt i -> fprintf fmt "%d" i
  | EBool b -> fprintf fmt "%b" b
  | UnaryOp (op, e) -> fprintf fmt "(%a %a)" pp_unary_op op pp_expr e
  | BinaryOp (op, e1, e2) -> fprintf fmt "(%a %a %a)" pp_expr e1 pp_binary_op op pp_expr e2
  | Var v -> fprintf fmt "%s" v
  | Fun (x, y, e) -> fprintf fmt "fun %s %s -> %a" x y pp_expr e
  | App (e1, e2) -> fprintf fmt "(%a %a)" pp_expr e1 pp_expr e2
  | Let (x, e1, e2) -> fprintf fmt "let %s = %a in %a" x pp_expr e1 pp_expr e2
  | Ifte (e1, e2, e3) -> fprintf fmt "if %a then %a else %a" pp_expr e1 pp_expr e2 pp_expr e3

(* Pretty-printer for environments *)
let rec pp_env fmt env =
  fprintf fmt "[";
  List.iter (fun (x, v) -> fprintf fmt "(%s, %a); " x pp_value v) env;
  fprintf fmt "]"

(* Pretty-printer for values *)
and pp_value fmt = function
  | VInt i -> fprintf fmt "%d" i
  | VBool b -> fprintf fmt "%b" b
  | VClo (x, y, e, env) ->
      fprintf fmt "(fun %s %s -> %a, %a)" x y pp_expr e pp_env env